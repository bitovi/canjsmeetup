<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en"> <!--<![endif]-->
<head>
<title>CanJS - Recipes</title>
<link rel="stylesheet" type="text/css" href="stylesheets/styles.css">
<link rel="stylesheet" type="text/css" href="stylesheets/tango.css">
<link href='/favicon.ico' rel='shortcut icon' type='image/x-icon' />
</head>
<body>
<div id='bg'>
</div>
<div class='cf' id='wrapper'>
	<div id='menu-wrapper'>
		<div id='header'>
			<div id='logo-and-download'>
				<a href="http://canjs.us/" class="logo"></a>
			</div>
		</div>
		<div class='cf' id='buttons'>
			<a href='https://forum.javascriptmvc.com/canjs'>Forums</a>
			<a href='http://bitovi.com/blog/tag/canjs/'>Blog</a>
			<a href='https://twitter.com/canjs'>Twitter</a>
			<a href='http://webchat.freenode.net?channels=canjs'>IRC</a>
		</div>
		<!--div id="feeder-wrap">
			<h4>Latest activity</h4>
			<div id="feeder-latest"></div>
		</div-->
		
		<div id="inner-menu-wrap">
			<ul id='menu'></ul>
		</div>
		<a href='http://bitovi.com' id='developed-by'>
		<img alt="Bitovi" src="images/bitovi.png"/>
		</a>
	</div>
	<div id='content-wrapper'>
		<div id='content'>
			<h1 id='canjs_recipes'>CanJS Recipes</h1>

<p>The following is a list of <strong>CanJS</strong> recipes to help you learn CanJS. To add your own, simply <a href='https://github.com/bitovi/canjs/edit/gh-pages/recipes.md'>edit this file</a>. To help create a JSFiddle, we&#8217;ve created the following fiddles you can fork:</p>

<ul>
<li><a href='http://jsfiddle.net/donejs/qYdwR/'>jQuery and CanJS</a></li>

<li><a href='http://jsfiddle.net/donejs/7Yaxk/'>Zepto and CanJS</a></li>

<li><a href='http://jsfiddle.net/donejs/9x96n/'>Dojo and CanJS</a></li>

<li><a href='http://jsfiddle.net/donejs/w6m73/'>YUI and CanJS</a></li>

<li><a href='http://jsfiddle.net/donejs/mnNJX/'>Mootools and CanJS</a></li>
</ul>

<h2 id='controls'>Controls</h2>

<p>The following recipes explore making UI widgets with <code>can.control</code>.</p>

<h3 id='tabs'>Tabs</h3>

<p>The following recipes builds a simple tabs widget.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/wSaGm/1/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
It creates a `Tabs` constructor function that shows and hides tabs
when it's `&lt;li&gt;`'s are clicked.

When `new Tabs()` is called, it adds `active` to the first `&lt;li>`'s 
className. Then, using the `tab` helper function, it hides the content for 
all the other tab buttons.



<div class='highlight'><pre><code class='html'><span class='nt'>&lt;li&gt;&lt;a</span> <span class='na'>href=</span><span class='s'>&quot;#model&quot;</span><span class='nt'>&gt;</span>Model<span class='nt'>&lt;/a&gt;&lt;/li&gt;</span>
</code></pre></div>


Then gets it's `&lt;a&gt;` element, and then uses it's href (`#model`) to get the
content div for that button.

When a button is clicked, `Tabs` listens to it with:


<div class='highlight'><pre><code class='javascript'><span class='s2'>&quot;li click&quot;</span> <span class='o'>:</span> <span class='kd'>function</span><span class='p'>(</span> <span class='nx'>el</span><span class='p'>,</span> <span class='nx'>ev</span> <span class='p'>)</span> <span class='p'>{</span> <span class='p'>...</span> <span class='p'>}</span>
</code></pre></div>


This function, using the `tab` helper deactivates the active tab button and hides its content, 
then it activates and shows the new tab button and tab content.
</div>
<h3 id='tooltip'>Tooltip</h3>

<p>The following recipe builds a simple tooltip. It shows templated event binding and we will explain how it keeps memory leaks from happening. Click on one of the items to see a tooltip, click somewhere else to remove it.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/imjoshdean/2VQSb/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
This creates a `Tooltip` control that when created shows a tooltip.  When a `Tooltip` control
is created, it positions the `Tooltip` element relative to the `relativeTo` option and 
sets its inner html to the `html` option.

The tooltip also listens to clicks on the window.  If the user clicked on something other than the
`relativeTo` element and the tooltip element, it will remove the tooltip from the document.

When an element is removed from the DOM with any controls on it, the control's event handlers
are automatically removed.  Templated event binding lets us listen to events outside 
the element.  `"{window} click"` is a templated event binding.

Events outside an element would normally not be removed, but they are with `can.Control`.
</div>
<h3 id='treecombo'>TreeCombo</h3>

<p>Select multiple items in a tree-like structure. This control uses <code>can.Observe.List</code> and <code>can.compute</code> in a smart way to manage the state of the widget.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/sTLhX/35/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe>
<p><a href='http://bitovi.com/blog/2013/01/weekly-widget-tree-combo.html'>How it works</a></p>

<h2 id='routing'>Routing</h2>

<p>The following recipes explore using <code>can.route</code>.</p>

<h3 id='history_tabs'>History Tabs</h3>

<p>This recipe shows how to make a history-based tabs widget and have routes configured independently by can.route.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/Z9Cv5/2/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
The HTML is structured such that each tab button has an `&lt;a&gt;` element with an 
href property that matches the `id` attribute of the tab content 
panel it should show.  This means that even if JavaScript was disabled,
clicking a button would send the user to the tab panel (even though
HistoryTabs overwrites this behavior).

For example:


<div class='highlight'><pre><code class='html'><span class='nt'>&lt;li&gt;&lt;a</span> <span class='na'>href=</span><span class='s'>&quot;#model&quot;</span><span class='nt'>&gt;</span>can.Model<span class='nt'>&lt;/a&gt;&lt;/li&gt;</span>
</code></pre></div>


references:


<div class='highlight'><pre><code class='html'><span class='nt'>&lt;div</span> <span class='na'>id=</span><span class='s'>&quot;model&quot;</span> <span class='na'>class=</span><span class='s'>&quot;tab&quot;</span><span class='nt'>&gt;</span>
</code></pre></div>


The JavaScript code begins by creating a `HistoryTabs` 
control.  When a new `HistoryTabs` instance is created, it gets
an __attr__ option like:


<div class='highlight'><pre><code class='javascript'><span class='k'>new</span> <span class='nx'>HistoryTabs</span><span class='p'>(</span> <span class='s1'>&#39;#components&#39;</span><span class='p'>,{</span><span class='nx'>attr</span><span class='o'>:</span> <span class='s1'>&#39;component&#39;</span><span class='p'>});</span>
</code></pre></div>


The __attr__ method is used to configure which part of `can.route`'s data the 
history tab will be listening to.  

When `init` is called, it hides each tab button's content div, looking up
the content div with the `tab` helper method.  It then reads the current 
active tab with:


<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>active</span> <span class='o'>=</span> <span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>.</span><span class='nx'>attr</span><span class='p'>(</span><span class='k'>this</span><span class='p'>.</span><span class='nx'>options</span><span class='p'>.</span><span class='nx'>attr</span><span class='p'>);</span>
</code></pre></div>


It passes that value to the `active` helper which will hide the old active
content (if `oldActive` is passed) and activate the new active button and
show it's content.

`HistoryTab` updates the active tab by listening when a tab button is clicked with
`"li click"`.  It prevents the default behavior (which is changing the hash) and
updates it's route data attribute with the select tab's id:


<div class='highlight'><pre><code class='javascript'><span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>.</span><span class='nx'>attr</span><span class='p'>(</span><span class='k'>this</span><span class='p'>.</span><span class='nx'>options</span><span class='p'>.</span><span class='nx'>attr</span><span class='p'>,</span> <span class='k'>this</span><span class='p'>.</span><span class='nx'>tab</span><span class='p'>(</span><span class='nx'>el</span><span class='p'>)[</span><span class='mi'>0</span><span class='p'>].</span><span class='nx'>id</span><span class='p'>)</span>
</code></pre></div>


`HistoryTabs` listens to these route changes with `"{can.route} {attr}"` and activates
the new tab.

__Configuring Routes__

The code ends by configuring the routes and creating the `HistoryTabs`.  Here's what each
route rule means:


<div class='highlight'><pre><code class='javascript'><span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>(</span><span class='s2'>&quot;:component&quot;</span><span class='p'>,{</span>
  <span class='nx'>component</span><span class='o'>:</span> <span class='s2'>&quot;model&quot;</span><span class='p'>,</span>
  <span class='nx'>person</span><span class='o'>:</span> <span class='s2'>&quot;mihael&quot;</span>
<span class='p'>});</span>
</code></pre></div>


This matches the empty routes ("","#","#!"), and a single "word" route.  If the route
is one of the empty routes, the route data will look 
like: `{component: "modal", person: "mihael"}`.  If it is a single "word" route like
`"#!view"`, the data will look like:  `{component: "view", person: "mihael"}`.


<div class='highlight'><pre><code class='javascript'><span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>(</span><span class='s2'>&quot;:component/:person&quot;</span><span class='p'>,{</span>
  <span class='nx'>component</span><span class='o'>:</span> <span class='s2'>&quot;model&quot;</span><span class='p'>,</span>
  <span class='nx'>person</span><span class='o'>:</span> <span class='s2'>&quot;mihael&quot;</span>
<span class='p'>});</span>
</code></pre></div>


This matches two-word routes seperated by a slash ("/").  Each word can be empty. If both
words are empty "#!/", the data will look 
like: `{component: "model", person: "mihael"}`.  If the words are non-empty, that word
will replace the default value.
</div>
<h3 id='observe_backed_routes'>Observe Backed Routes</h3>

<p>This recipe shows how to have multiple widgets listening on overlapping parts of the route. The app lets the user select a type of issue, show issues for that type, and select a issue and see details about that issue.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/2UL6R/1/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
This functionality is broken down 
into __Nav__, __Issues__, and __Details__ can.controls.  Here's how
each part works:

`Nav` creates links using `can.route.link` that update the hash like:


<div class='highlight'><pre><code class='javascript'><span class='o'>&lt;%==</span> <span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>.</span><span class='nx'>link</span><span class='p'>(</span><span class='s2'>&quot;Critical&quot;</span><span class='p'>,{</span><span class='nx'>filter</span><span class='o'>:</span> <span class='s2'>&quot;critical&quot;</span><span class='p'>})</span> <span class='o'>%&gt;</span>
</code></pre></div>


When these are clicked on, they update the route's filter data.  

`Issues` listens to filter changes like:


<div class='highlight'><pre><code class='javascript'><span class='s2'>&quot;{can.route} filter&quot;</span> <span class='o'>:</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>route</span><span class='p'>,</span> <span class='nx'>ev</span><span class='p'>,</span> <span class='nx'>filter</span><span class='p'>){</span> <span class='p'>...</span> <span class='p'>}</span>
</code></pre></div>


It then retrieve's issue with `Issue.findAll` and renders 
them into the `#issues` element.

When an issue is clicked, `Issues` updates the route's issue data like:


<div class='highlight'><pre><code class='javascript'><span class='nx'>can</span><span class='p'>.</span><span class='nx'>route</span><span class='p'>.</span><span class='nx'>attr</span><span class='p'>(</span><span class='s2'>&quot;issue&quot;</span><span class='p'>,</span> <span class='nx'>issue</span><span class='p'>.</span><span class='nx'>id</span><span class='p'>)</span>
</code></pre></div>


It listens to changes in `issue` data and highlights the corresponding
issue in the list like:


<div class='highlight'><pre><code class='javascript'><span class='s2'>&quot;{can.route} issue&quot;</span> <span class='o'>:</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>route</span><span class='p'>,</span> <span class='nx'>ev</span><span class='p'>,</span> <span class='nx'>issue</span><span class='p'>){</span> <span class='p'>...</span> <span class='p'>}</span>
</code></pre></div>


`Details` listens to issue chagnes like:


<div class='highlight'><pre><code class='javascript'><span class='s2'>&quot;{can.route} issue&quot;</span> <span class='o'>:</span> <span class='kd'>function</span><span class='p'>(</span><span class='nx'>route</span><span class='p'>,</span> <span class='nx'>ev</span><span class='p'>,</span> <span class='nx'>issue</span><span class='p'>){</span> <span class='p'>...</span> <span class='p'>}</span>
</code></pre></div>


And updates the details panel.
</div>
<h2 id='live_binding'>Live Binding</h2>

<p>The following recipes show how to use <code>can.EJS</code>&#8217;s live binding.</p>

<h3 id='updating_timestamps'>Updating timestamps</h3>

<p>The following shows how to create an automatically updating <code>prettyDate</code> helper for EJS that can be used like:</p>
<div class='highlight'><pre><code class='javascript'><span class='o'>&lt;%=</span> <span class='nx'>prettyDate</span><span class='p'>(</span> <span class='k'>new</span> <span class='nb'>Date</span><span class='p'>()</span> <span class='p'>)</span> <span class='o'>%&gt;</span>
</code></pre></div>
<p>Notice how the <em>created</em> value changes every couple min or so.</p>

<p>The <code>prettyDate</code> method works with or without live-binding. It doesn&#8217;t need to take an observe, just a date. Code with EJS becomes live naturally &#8230; amazing.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/qYdwR/36/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe>
<h3 id='2way_binding_mustache_helpers'>2-way binding Mustache helpers</h3>

<p>Learn how to make 2-way binding mustache helpers. When you change the value of an input, it automatically changes the value of an observe. When you change the value of the observe, it changes the value of the input.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/ztWS5/5/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe>
<p><a href='http://bitovi.com/blog/2013/01/weekly-widget-two-way-mustache-helpers.html'>How it works</a></p>

<h2 id='models'>Models</h2>

<p>The following recipes show how to use <code>can.Model</code> (and often the <code>can.fixture</code> plugin).</p>

<h3 id='showing_the_same_data_in_2_places'>Showing the same data in 2 places</h3>

<p>The following recipe shows how <code>can.Model</code>&#8217;s internal store and <code>can.view</code>&#8217;s live-binding can easily solve the editing-data-that-is-represented-two-places problem. It shows two task lists of overlaping data. Notice how the <strong>&#8220;do dishes&#8221;</strong> is listed twice. But if you click one &#8220;do dishes&#8221; checkbox, it updates the other.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/moschel/pCtxs/15/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
The code first sets up a `can.fixture` to return different, but overlapping lists of 
tasks from the server.  The fixture returns data from the following calls:

 - `/tasks?due=today`
 - `/tasks?type=critical`

You'll notice "do dishes" in both lists.

The code then creates a `Task` model that maps findAll to `/tasks`.  It then uses
`can.view` to render the retrieved tasks with the `tasksEJS` template. 

Finally, it listens when an `input` element's value changes.  When it does,
it gets the task model instance from the `li` element's `$.data` and 
updates it's "complete" property.

___The Secret Sauce___

Model keeps an internal, non-leaking, store of instances your app loads.  When
`Task.findAll({type: "critical"})` and `Task.findAll({due: "today"})` get their
raw JSON data from the server, they convert it to instances.  But before they create
a new instance, they check if the same instance, matched by 
the [id](http://donejs.com/docs.html#!can.Model.static.id) property already exists.  If it
does, it uses that instance. 

This means that the `criticalTasks` list and `todaysTasks` list both point to the 
same instance. When `can.EJS` does it's live binding on `&lt;%= task.attr("complete") ? "checked" : "" %&gt;`
it's actually binding on the same "do dishes" intance once.  So updating "do dishes" updates
the DOM in two places!
</div>
<h3 id='caching_data_in_local_storage'>Caching Data in Local Storage</h3>

<p>The following recipe shows how <code>can.Model</code> can be used to create an ORM-like model layer for keeping a local copy of a restful API. This type of base model is perfect for situations where you want a responsive UI, but may not want to wait for updates from the server before displaying data, or you need to make your data persist offline. Storing your responses in <code>localStorage</code> allows you to get data to the view as quickly as possible.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/moschel/73Xuk/14/embedded/result%2Cjs/' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
When creating your base model for other models to extend from, you can prefix 
static service methods with `make`, to allow the base model to define how the 
extending model's method will behave. In this example, our base model implements
a static method called `makeFindOne`. This method acts as a hook to define the 
extending model's `findOne` method. Using this, we can create a middleware-like
layer between the extending model and the base model that loads and saves model
data to `localStorage`, while still requesting out to the restful API to get 
updates.

___The Secret Sauce___

The secret sauce for this example is the static `makeFindOne` method along with
EJS's live binding. Because the live binding will automatically update the view when the 
bound model gets updated, we can write our code as usual and allow the base model
to deliver `localStorage` data instantly, while automatically upating with responses
from the server, with no extra effort.
</div>
<h3 id='real_time_chat'>Real Time Chat</h3>

<p>Type a message in one page, it instantly shows up in the other.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/' style='width: 100%; height: 300px'>JSFiddle</iframe><iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/' style='width: 100%; height: 300px'>JSFiddle</iframe>
<p><a href='http://bitovi.com/blog/2013/02/weekly-widget-chat.html'>How it works</a></p>

<h2 id='everything_together'>Everything Together</h2>

<p>The following recipes show a bunch of functionality working together.</p>

<h3 id='basic_todo'>Basic Todo</h3>

<p>This recipe demonstrates the very basic todo app covered on <span>http://canjs.us</span>. You can select a todo and edit it&#8217;s text. You can also delete a todo. The app is also history enabled, letting you move forward and back through different todos.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/moschel/5zpFz/94/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe><a class='how' href='javascript:void(0)'>How it works</a><div class='how_expanded'>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='480' src='http://www.youtube.com/embed/PfTbkzh07iE' width='640'>YouTube</iframe>


The app starts by creating a `Todo` model that connects to a dummy data 
store (just an array). The `findAll`, `findOne`, `update` and `destroy` methods
simply returning the required deferreds.

It then creates a `Todos` control that manages a list of `todos`.  When a new Todos control is created
on an element via `new Todos("#todos")` it uses the `Todo` model to findAll todo instances,
renders them with `todosEJS` and inserts them into the `Todos` control instance's element.

The template `todosEJS` iterates through each todo instance using `list`.  For each todo,
it creates an `&lt;li&gt;` element.  It adds the instance's data to the `&lt;li&gt;` element's `$.data` 
with: `<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>editor</span> <span class='o'>=</span> <span class='k'>new</span> <span class='nx'>Editor</span><span class='p'>(</span><span class='s2'>&quot;#editor&quot;</span><span class='p'>)</span>
</code></pre></div>


And an instance to edit is passed like:


<div class='highlight'><pre><code class='javascript'><span class='nx'>editor</span><span class='p'>.</span><span class='nx'>todo</span><span class='p'>(</span> <span class='nx'>todo</span> <span class='p'>);</span>
</code></pre></div>


When `editor.todo( todo )` is called, it updates the editor's todo option and calls `this.on()`. This rebinds 
the editor's event handlers like `"{todo} updated"` and `"{todo} destroyed"` to bind to the 
updated todo option.  Then it calls `this.setName()` which updates the 
editor element's value.  

`"{todo} updated"` listens when a todo has been updated on the server and updates the name.

`"{todo} destroyed"` hides the editor if it's todo has been destroyed.

`"change"` listens to the input element's value changing, updates the todo's __name__ attribute and saves 
it to to the server.

Finally a `Routing` control constructor is created that manages the interaction between an `Editor` and
`Todos` control.  `Routing` is a traditional controller, while `Editor` and `Todos` are traditional
views. When a new `Routing` is created, it creates an `Editor` and `Todos` control.  It also
listens to changes in routes with `"route"` and `"todos/:id route"`.  

`"route"` matches when the hash is empty and hides the editor.

`"todos/:id route"` matches when the route is like `#!todos/5`.  When this happens, it shows the 
editor, loads that Todo with the model, and passed it to the editor.

`Routing` also listens to an `"li selected"` event.  This is the event created by 
the `Todos` control.  When this event happens, `Routing` updates the hash with the select todo's id.
</div>
<h3 id='paginated_grid_with_buttons'>Paginated Grid with Buttons</h3>

<p>Paginate through a list of links. This recipe shows how to use <code>can.Observe</code> can <code>can.compute</code> to organize client state and pass it to child controls.</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://jsfiddle.net/SyEXx/4/embedded/result,html,js,css' style='width: 100%; height: 300px'>JSFiddle</iframe>
<p><a href='http://bitovi.com/blog/2013/02/weekly-widget-paginated-grid.html'>How it works</a></p>
		</div>
	</div>
</div>
<script src="javascripts/jquery-1.7.1.js" type="text/javascript"></script>
<script src="javascripts/can.jquery-1.0.2.js" type="text/javascript"></script>
<script src="javascripts/can.construct.proxy.js" type="text/javascript"></script>
<script src="javascripts/hover.js" type="text/javascript"></script>
<script type="text/javascript" src="http://bithub.com/socket.io/socket.io.js"></script>
<script src="http://bithub.com/widget/feeder-widget.js" type="text/javascript"></script>
<script src="javascripts/application.js" type="text/javascript"></script>
</body>
</html>
